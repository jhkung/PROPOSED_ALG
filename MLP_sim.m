%% 15 TCAD: Feedforward NN (MLP) with multiple hidden layers (vectorized)
%% Code generated by dkim & jkung

clc;
clear all;
close all;

global BENCHMARK;
% BENCHMARK = 'MNIST';
%  BENCHMARK = 'CIFAR10';
% BENCHMARK = 'LETTER';
BENCHMARK = 'CNAE-9';

%% Initialization(1): set MLP Network Architecture
if strcmp(BENCHMARK, 'MNIST')    
    inputSize  = 28*28;    hiddenSize 	= [12*12, 8*8];    outputSize   = 10;
elseif strcmp(BENCHMARK, 'CIFAR10')
    inputSize  = 3*32*32;  hiddenSize   = [32*32];  outputSize   = 10;
elseif strcmp(BENCHMARK, 'LETTER')
    inputSize  = 16;       hiddenSize   = [64];        outputSize   = 26;
elseif strcmp(BENCHMARK,'CNAE-9')
    inputSize  = 856;  hiddenSize   = [12*12, 8*8];  outputSize   = 9;
end

global N_layer;     % number of MLP layers except input layer
N_layer 	= size(hiddenSize, 2) + 1;

global mat_size;
mat_size    = setMatrixSize(inputSize, hiddenSize, outputSize);
initTheta 	= initializeParameters(inputSize);
w_length    = inputSize*hiddenSize(1);
for i = 1:N_layer-2
    w_length = w_length + hiddenSize(i)*hiddenSize(i+1);
end    
w_length    = w_length + hiddenSize(N_layer-1)*outputSize;

global network_arch;
network_arch.inputSize   = inputSize;        network_arch.hiddenSize  = hiddenSize;
network_arch.outputSize  = outputSize;       network_arch.w_length    = w_length;


%% Initialization(2): load dataset
if strcmp(BENCHMARK, 'MNIST')
    addpath ./RAW_DATA/mnist/
    [ mnistData, mnistLabels ] 	= loadMNIST();
    
    % one-hot encoding
    temp_labels = onehotEncode(mnistLabels);
    
    num_train 	= 50000;
    trainData 	= mnistData(:,1:num_train);
    trainLabels = temp_labels(:,1:num_train);
    
    test_range  = [50001:60000];
    testData    = mnistData(:,test_range);
    testLabels  = temp_labels(:,test_range);
    testLabels_one = mnistLabels(test_range);
elseif strcmp(BENCHMARK, 'CIFAR10')
    addpath ./RAW_DATA/cifar-10/
    [ trainData, trainLabels, testData, testLabels_one ] = loadDataSet();     % 50000 train data
    trainData   = trainData';
    testData    = testData';
    
    trainLabels = onehotEncode(trainLabels);
    testLabels  = onehotEncode(testLabels_one);
elseif strcmp(BENCHMARK, 'LETTER')
    addpath ./RAW_DATA/letter/
    [ trainData, trainLabels, testData, testLabels_one ] = loadDataSet();     % 16000 train data, 4000 test data
    
    trainLabels = onehotEncode(trainLabels);
    testLabels  = onehotEncode(testLabels_one);
elseif strcmp(BENCHMARK, 'CNAE-9')
    addpath ./RAW_DATA/cnae-9
    cnae_9_data = load('CNAE-9.data'); %1080 * 857 double matrix
    [num_data,num_attribute] = size(cnae_9_data);
    Data = cnae_9_data(:,(2:857))';
    Labels = onehotEncode(cnae_9_data(:,1)); %10-bit one-hot-encoding
                    
    trainData = Data(:,(1:927));
    trainLabels = Labels(:,(1:927));
    trainLabels = trainLabels((2:10),:);     % 9 classes [1-9]
    
    testData = Data(:,(928:1080));
    testLabels = Labels(:,(928:1080));
    testLabels = testLabels((2:10),:);       % 9 classes [1-9]
end


%% Initialization(3): read error distribution of apprx multiplier
global err_data;
err_data = load('recover_10_20_forcing_prec_from_0_to_24.mat');


%% Initialization(4): set hardware parameters
SET_precision_arr       = [32 24;       28 20;          24 16;          20 12;         16 8;            12 6;           8 4     ];
SET_accurate_pow_arr    = [12.84e-3,    12.312e-3,      11.514e-3,      10.29e-3,      9.264e-3,        7.962e-3,       6.05e-3 ];      % 32 28 24 20 16 12 8
SET_apprx_pow_arr       = [9.156e-3,    8.364e-3,       7.062e-3,       5.52e-3,       3.738e-3,        2.33e-3,        1.032e-3];      % 32 28 24 20 16 12 8
SELECT_prec_mode        = [1,           0,              0,              0,             1,               0,              1       ];      % select subset of precision SET

num_prec_modes      = length(find(SELECT_prec_mode==1));
accurate_pow_arr    = SET_accurate_pow_arr(find(SELECT_prec_mode==1));
apprx_pow_arr       = SET_apprx_pow_arr(find(SELECT_prec_mode==1));
precision_arr       = SET_precision_arr(find(SELECT_prec_mode==1),:);

global hw_info;
hw_info{1}.num_prec_modes   = num_prec_modes;       hw_info{1}.acc_pow_arr      = accurate_pow_arr;
hw_info{1}.apprx_pow_arr    = apprx_pow_arr;        hw_info{1}.prec_arr         = precision_arr;

global recovery;    recovery = 20;
global rApprox;     rApprox = 0.4;      % To turn off, approximate multiplier, set rApprox =0; (rApprox = 0.4, set on 150304)
power_arr = rApprox * apprx_pow_arr + (1-rApprox) * accurate_pow_arr;


%% Initialization(5): read previously trained network
trainPrecSet    = [32 24; 28 20; 24 16; 20 12; 16 8];
% trainPrecSet    = [32 24; 28 20; 24 16; 20 12];
RESULT          = cell(1,length(trainPrecSet));

for test_idx = 1:length(trainPrecSet)
    trainPrec   = trainPrecSet(test_idx,1);       trainFloatPrec  = trainPrecSet(test_idx,2);
    [trainPrec, trainFloatPrec]
    filename    = strcat('trainedResult\',BENCHMARK,'_',num2str(trainPrec),'_',num2str(trainFloatPrec),'.mat');
    trainedResult   = load(filename);     % load pre-trained data
    
    PT_data     = trainedResult.result;
    optTheta    = PT_data.opt_theta{1};
    grad        = PT_data.grad{1};       
    
    % Approximate mutliplier
    stackedApproxMat    = zeros(w_length,1);
    [B, IDX]            = sort(abs(grad(1:w_length)));
    mask_IDX            = IDX(1:round(w_length*rApprox));
    stackedApproxMat(mask_IDX') = 1;
    apprx_mat          = unstackMat(stackedApproxMat);
    
    %% Main operation of the proposed algorithm    
    %% Initialize precision rate before autotuning
    % prec_rate = zeros(1,num_prec_modes);
    % prec_rate(end) = 1;
    % prec_rate = [rPrec of 32bit, rPrec of 16bit, rPrec of 8bit]
    prec_rate =  [0 0 1];
    [ prec_mat ] = gen_prec_mat(prec_rate, IDX);
        
    
    %% Optimization
    % 1. before starting while-loop, do initial run
    total_hist = zeros(1,length(prec_rate) + 2);
    
    hist_prec = zeros(1,length(prec_rate));     % stores the history of selected bit precisions
    sprintf('RUNNING INITIAL PRECISION CONTROLLED TESTING W/ APPRX MULTIPLIER')
    
    [cost,predict] = prec_apprx_forwardPass(optTheta, inputSize, hiddenSize, outputSize, testData, testLabels, prec_mat, apprx_mat, 0);
    
    [M, I]		= max(predict);   
    
    if strcmp(BENCHMARK, 'CNAE-9')
        pred        = I';
        recog_rate  = mean(cnae_9_data((928:1080),1) == pred(:))
    else
        pred 		= (I' - 1);
        recog_rate  = mean(testLabels_one(:) == pred(:))
    end
            
    avg_Pcurr   = computePower(prec_rate) * 1e3
    hist_prec(length(hist_prec(:,1))+1,:) = prec_rate;
    total_hist(1,:) = [ avg_Pcurr, recog_rate, prec_rate]
    
    
    % 2. while loop to achieve optimum precision ratio
    beta = 0.1;     iter = 1;
    Target_recog_rate = 0.98 * PT_data.avg_accuray; 
    prev_recog_rate = recog_rate;
    prev_avg_Pcurr  = avg_Pcurr;
    
    if (Target_recog_rate < 0.7)
        error_str = 'SKIP THIS TRAINING SET!!'
        break;
    end
    
    while ( prev_recog_rate < Target_recog_rate )
        
%         prev_recog_rate = recog_rate;
%         prev_avg_Pcurr  = avg_Pcurr;
        
        [new_prec_rate_1, new_prec_rate_2] = next_prec_rate( prec_rate, beta );
        cost_1 = -100;      % initially large negative value
        cost_2 = -100;      % initially large negative value
        
        if ( ~isempty(find(new_prec_rate_1 < 0)) || ~isempty(find(new_prec_rate_2 < 0)) )
            break
        end
        
        if (~is_tried_before(hist_prec,new_prec_rate_1))
            
            hist_prec(length(hist_prec(:,1))+1,:) = new_prec_rate_1;
            [ prec_mat ] = gen_prec_mat(new_prec_rate_1, IDX);
            sprintf('RUNNING PRECISION CONTROLLED APPROXIMATE TESTING 1')
            new_prec_rate_1
            [cost,predict] = prec_apprx_forwardPass(optTheta, inputSize, hiddenSize, outputSize, testData, testLabels, prec_mat, apprx_mat, 0);[M, I]		= max(predict);
            
            if strcmp(BENCHMARK, 'CNAE-9')
                pred        = I';
                recog_rate  = mean(cnae_9_data((928:1080),1) == pred(:))
            else
                pred 		= (I' - 1);
                recog_rate1 = mean(testLabels_one(:) == pred(:));
            end
            
            avg_Pcurr1  = computePower(new_prec_rate_1) * 1e3;
            
            
            cost_1 = 0.7*(recog_rate1 - prev_recog_rate)/prev_recog_rate - 0.3*(avg_Pcurr1 - prev_avg_Pcurr)/prev_avg_Pcurr;
            sprintf(' [Iter %d] Test 1: accuracy : %f, power: %f, cost_1: %f',iter, recog_rate1, avg_Pcurr1, cost_1)
        end
        
        if (~is_tried_before(hist_prec,new_prec_rate_2))
            hist_prec(length(hist_prec(:,1))+1,:) = new_prec_rate_2;
            [ prec_mat ] = gen_prec_mat(new_prec_rate_2, IDX);
            sprintf('RUNNING PRECISION CONTROLLED APPROXIMATE TESTING 2')
            new_prec_rate_2
            [cost,predict] = prec_apprx_forwardPass(optTheta, inputSize, hiddenSize, outputSize, testData, testLabels, prec_mat, apprx_mat, 0);[M, I]		= max(predict);
            
            if strcmp(BENCHMARK, 'CNAE-9')
                pred        = I';
                recog_rate  = mean(cnae_9_data((928:1080),1) == pred(:))
            else
                pred 		= (I' - 1);
                recog_rate2 = mean(testLabels_one(:) == pred(:));
            end
            
            avg_Pcurr2  = computePower(new_prec_rate_2) * 1e3;
            
            cost_2 = 0.7*(recog_rate2 - prev_recog_rate)/prev_recog_rate - 0.3*(avg_Pcurr2 - prev_avg_Pcurr)/prev_avg_Pcurr;
            sprintf(' [Iter %d] Test 2: accuracy : %f, power: %f, cost_2: %f', iter, recog_rate2, avg_Pcurr2, cost_2)
        end
        
        if cost_1 > cost_2
            sprintf(' Cost 1 win !!')
            if (recog_rate1 < prev_recog_rate)
                str_msg = '[ABORTED] ACCURACY WORSENED!'
                break
            end
            
            prev_avg_Pcurr = avg_Pcurr1;           
            prev_recog_rate = recog_rate1;
            prec_rate = new_prec_rate_1;
        else
            sprintf(' Cost 2 win !!')
            if (recog_rate2 < prev_recog_rate)
                str_msg = '[ABORTED] ACCURACY WORSENED!'
                break
            end
            
            prev_avg_Pcurr = avg_Pcurr2;            
            prev_recog_rate = recog_rate2;
            prec_rate = new_prec_rate_2;
        end
        
        total_hist(iter+1,:) = [ prev_avg_Pcurr, prev_recog_rate, prec_rate]
        iter=iter+1
        
        if iter > 20
            break
        end
        
    end
    
    RESULT{test_idx}    = total_hist;
end     % END trainPrecSet iteration

output_filename = strcat(BENCHMARK,'_output.mat');
save(output_filename,'RESULT');




